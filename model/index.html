<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fortsa model - fortsa api documents</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded "><a href="../stats/index.html"><strong aria-hidden="true">2.</strong> fortsa stats</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../stats/acf.html"><strong aria-hidden="true">2.1.</strong> acf</a></li><li class="chapter-item expanded "><a href="../stats/pacf.html"><strong aria-hidden="true">2.2.</strong> pacf</a></li></ol></li><li class="chapter-item expanded "><a href="../model/index.html" class="active"><strong aria-hidden="true">3.</strong> fortsa model</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">fortsa api documents</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/zoziha/fortsa/tree/main/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                                        <a href="https://github.com/zoziha/fortsa/edit/main/doc/src/model/README.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fortsa_model"><a class="header" href="#fortsa_model">fortsa_model</a></h1>
<p><code>fortsa_model</code> contains useful time series models.</p>
<pre><code class="language-fortran">!! `Fortran-TSA-api.f90` will be the `C-Fortran` interface to [rafat/CTSA](https://github.com/rafat/ctsa)

module fortsa_model

    use, intrinsic :: iso_c_binding, only: c_int, c_double, c_char, c_ptr, c_null_ptr, c_loc
    implicit none
    private

    public :: arima_set, arima_init, arima_setMethod, arima_setOptMethod, &amp;
              arima_exec, arima_summary, arima_predict, arima_free
              
    public :: ar_init, ar_exec, &amp;
              ar_summary, ar_predict, &amp;
              ar_free

    public :: auto_arima_init, auto_arima_setApproximation, auto_arima_exec, &amp;
              auto_arima_summary, auto_arima_predict, &amp;
              auto_arima_free, auto_arima_setStepwise, auto_arima_setVerbose

    public :: sarima_init, sarima_predict, sarima_setMethod, sarima_setOptMethod, &amp;
              sarima_vcov, sarima_exec, sarima_free, sarima_summary

    public :: sarimax_init, sarimax_setMethod, sarimax_exec, &amp;
              sarimax_summary, sarimax_predict, sarimax_free

    public :: yw, burg, hr
    
    public :: auto_arima_set

    type, bind(c) :: auto_arima_set
        integer(c_int) :: N        !! length of time series
        integer(c_int) :: Nused    !! length of time series after differencing, Nused = N - d
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: pmax     !! Maximum size of phi
        integer(c_int) :: dmax     !! Maximum Number of times the series is to be differenced
        integer(c_int) :: qmax     !! Maximum size of theta
        integer(c_int) :: pmax_    !! Maximum Size of seasonal phi
        integer(c_int) :: dmax_    !! Maximum number of times the seasonal series is to be differenced
        integer(c_int) :: qmax_    !! Maximum size of Seasonal Theta
        integer(c_int) :: p        !! size of phi
        integer(c_int) :: d        !! Number of times the series is to be differenced
        integer(c_int) :: q        !! size of theta
        integer(c_int) :: s        !! Seasonality/Period
        integer(c_int) :: p_       !! Size of seasonal phi
        integer(c_int) :: d_       !! The number of times the seasonal series is to be differenced
        integer(c_int) :: q_       !! size of Seasonal Theta
        integer(c_int) :: r        !! Number of exogenous variables
        integer(c_int) :: M        !! M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !! Total Number of Coefficients to be estimated
        real(c_double) :: phi
        real(c_double) :: theta
        real(c_double) :: phi_
        real(c_double) :: theta_
        real(c_double) :: exog
        real(c_double) :: vcov     !! Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !! length of VCOV
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: ic
        integer(c_int) :: retval
        integer(c_int) :: start
        integer(c_int) :: imean
        integer(c_int) :: idrift
        integer(c_int) :: stationary
        integer(c_int) :: seasonal
        integer(c_int) :: Order_max
        integer(c_int) :: p_start
        integer(c_int) :: q_start
        integer(c_int) :: P_start_
        integer(c_int) :: Q_start_
        character(c_char), dimension(10) :: information_criteria
        integer(c_int) :: stepwise
        integer(c_int) :: num_models
        integer(c_int) :: approximation
        integer(c_int) :: verbose
        character(c_char), dimension(10) :: test
        character(c_char), dimension(10) :: type
        character(c_char), dimension(10) :: seas
        real(c_double) :: alpha_test
        real(c_double) :: alpha_seas
        real(c_double) :: lambda
        real(c_double) :: sigma2
        real(c_double) :: aic
        real(c_double) :: bic
        real(c_double) :: aicc
        real(c_double), dimension(0) :: params
    end type auto_arima_set

    interface
        function auto_arima_init(pdqmax, pdqmax_, s, r, N) bind(c, name='auto_arima_init')
            import c_int, c_ptr
            integer(c_int) :: pdqmax(*), pdqmax_(*)
            integer(c_int), value :: s, r, N
            type(c_ptr) :: auto_arima_init
        end function auto_arima_init
    end interface

    type, bind(c) :: sarimax_set
        integer(c_int) :: N        !! length of time series
        integer(c_int) :: Nused    !!length of time series after differencing, Nused = N - d
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: p        !! size of phi
        integer(c_int) :: d        !! Number of times the series is to be differenced
        integer(c_int) :: q        !!size of theta
        integer(c_int) :: s        !! Seasonality/Period
        integer(c_int) :: p_       !!Size of seasonal phi
        integer(c_int) :: d_       !! The number of times the seasonal series is to be differenced
        integer(c_int) :: q_       !!size of Seasonal Theta
        integer(c_int) :: r        !! Number of exogenous variables
        integer(c_int) :: M        !! M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !! Total Number of Coefficients to be estimated
        real(c_double) :: phi
        real(c_double) :: theta
        real(c_double) :: phi_
        real(c_double) :: theta_
        real(c_double) :: exog
        real(c_double) :: vcov     !! Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !!length of VCOV
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: aic
        integer(c_int) :: retval
        integer(c_int) :: start
        integer(c_int) :: imean
        real(c_double), dimension(0) :: params
    end type sarimax_set

    interface
        function sarimax_init(p, d, q, p_, d_, q_, s, r, imean, N) bind(c, name='sarimax_init')
            import c_int, c_ptr
            integer(c_int), value :: p, d, q, p_, d_, q_, s, r, imean, N
            type(c_ptr) :: sarimax_init
                !! `sarimax_set` struct
        end function sarimax_init
    end interface

    type, bind(c) :: arima_set
        integer(c_int) :: N        !! length of time series
        integer(c_int) :: Nused    !! length of time series after differencing, Nused = N - d
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: p        !! size of phi
        integer(c_int) :: d        !! Number of times the series is to be differenced
        integer(c_int) :: q        !! size of theta
        integer(c_int) :: s        !! Seasonality/Period
        integer(c_int) :: p_       !! Size of seasonal phi
        integer(c_int) :: d_       !! The number of times the seasonal series is to be differenced
        integer(c_int) :: q_       !! size of Seasonal Theta
        integer(c_int) :: r        !! Number of exogenous variables
        integer(c_int) :: M        !! M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !! Total Number of Coefficients to be estimated
        type(c_ptr) :: phi
        type(c_ptr) :: theta
        type(c_ptr) :: phi_
        type(c_ptr) :: theta_
        type(c_ptr) :: exog
        type(c_ptr) :: vcov     !! Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !! length of VCOV
        type(c_ptr) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: aic
        integer(c_int) :: retval
        integer(c_int) :: start
        integer(c_int) :: imean
        real(c_double), dimension(0) :: params
    end type

    ! type(c_ptr), bind(c, name='arima_object') :: arima_object

    interface
        function arima_init(p, d, q, N) bind(c, name='arima_init')
            import c_int, c_ptr
            integer(c_int), value :: p, d, q, N
            type(c_ptr) :: arima_init
        end function
    end interface

    type, bind(c) :: sarima_set
        integer(c_int) :: N        !!  length of time series
        integer(c_int) :: Nused    !! length of time series after differencing, Nused = N - d - s*D
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: p        !!  size of phi
        integer(c_int) :: d        !!  Number of times the series is to be differenced
        integer(c_int) :: q        !! size of theta
        integer(c_int) :: s        !!  Seasonality/Period
        integer(c_int) :: P_        !! Size of seasonal phi
        integer(c_int) :: D_        !!  The number of times the seasonal series is to be differenced
        integer(c_int) :: Q_        !! size of Seasonal Theta
        integer(c_int) :: M        !!  M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !!  Total Number of Coefficients to be estimated
        real(c_double) :: phi
        real(c_double) :: theta
        real(c_double) :: PHI_
        real(c_double) :: THETA_
        real(c_double) :: vcov    !!  Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !! length of VCOV
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: aic
        integer(c_int) :: retval
        real(c_double), dimension(0) :: params
    end type

    interface
        function sarima_init(p, d, q, s, p_, d_, q_, N) bind(c, name='sarima_init')
            import c_int, c_ptr
            integer(c_int), value :: p, d, q, s, p_, d_, q_, N
            type(c_ptr) :: sarima_init
        end function
    end interface

    type, bind(c) :: ar_set
        integer(c_int) :: N            !! length of time series
        integer(c_int) :: method
        integer(c_int) :: optmethod    !! Valid only for MLE estimation
        integer(c_int) :: p            !! size of phi
        integer(c_int) :: order        !! order = p
        integer(c_int) :: ordermax     !! Set Maximum order to be fit
        real(c_double) :: phi
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: aic
        integer(c_int) :: retval
        real(c_double), dimension(0) :: params
    end type

    interface
        function ar_init(method, N) bind(c, name='ar_init')
            import c_int, c_ptr
            integer(c_int), value :: method, N
            type(c_ptr) :: ar_init
        end function
    end interface

    interface
        ! exec routines 🔻
        subroutine ctsa_sarimax_exec(obj, inp, xreg) bind(c, name='sarimax_exec')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: inp(*)
            type(c_ptr), value :: xreg
        end subroutine ctsa_sarimax_exec

        subroutine arima_exec(obj, x) bind(c, name='arima_exec')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: x(*)
        end subroutine arima_exec

        subroutine sarima_exec(obj, x) bind(c, name='sarima_exec')
            import c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: x(*)
        end subroutine sarima_exec

        subroutine ctsa_auto_arima_exec(obj, inp, xreg) bind(c, name='auto_arima_exec')
            import c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*)
            type(c_ptr), value :: xreg
        end subroutine ctsa_auto_arima_exec

        subroutine ar_exec(obj, inp) bind(c, name='ar_exec')
            import c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*)
        end subroutine ar_exec
        ! predict routines 🔻
        subroutine arima_predict(obj, inp, L, xpred, amse) bind(c, name='arima_predict')
            import c_int, c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine arima_predict

        subroutine sarima_predict(obj, inp, L, xpred, amse) bind(c, name='sarima_predict')
            import c_int, c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine sarima_predict

        subroutine sarimax_predict(obj, inp, xreg, L, newxreg, xpred, amse) bind(c, name='sarimax_predict')
            import c_ptr, c_int, c_double
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xreg(*), newxreg(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine sarimax_predict

        !&gt; Predictes the next L values of the time series
        subroutine auto_arima_predict(obj, inp, xreg, L, newxreg, xpred, amse) bind(c)
            import c_int, c_ptr, c_double
            
            !&gt; Pointer points to `auto_arima_object`
            type(c_ptr), value :: obj
            
            !&gt; Input array
            real(c_double) :: inp(*)
            
            !&gt; TODO:
            real(c_double) :: xreg(*), newxreg(*)
            
            !&gt; Prediction array
            real(c_double) :: xpred(*)
            
            !&gt; Standard errors array
            real(c_double) :: amse(*)
            
            !&gt; Length of prediction
            integer(c_int), value :: L
            
        end subroutine auto_arima_predict

        subroutine ar_predict(obj, inp, L, xpred, amse) bind(c, name='ar_predict')
            import c_int, c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine ar_predict

        subroutine ar(inp, N, p, method, phi, var) bind(c, name='ar')
            import c_int, c_double
            real(c_double) :: inp, phi, var
            integer(c_int), value :: N, p, method
        end subroutine ar
        
        ! setMethod routines 🔻
        subroutine arima_setMethod(obj, value) bind(c, name='arima_setMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine arima_setMethod

        subroutine sarima_setMethod(obj, value) bind(c, name='sarima_setMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine sarima_setMethod

        subroutine auto_arima_setMethod(obj, value) bind(c, name='auto_arima_setMethod')
            import c_ptr, c_int
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine auto_arima_setMethod

        subroutine sarimax_setMethod(obj, value) bind(c, name='sarimax_setMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine sarimax_setMethod
        ! setOptMethod routines 🔻
        subroutine arima_setOptMethod(obj, value) bind(c, name='arima_setOptMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine arima_setOptMethod

        subroutine sarima_setOptMethod(obj, value) bind(c, name='sarima_setOptMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine sarima_setOptMethod

        subroutine auto_arima_setOptMethod(obj, value) bind(c, name='auto_arima_setOptMethod')
            import c_ptr, c_int
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine auto_arima_setOptMethod

        subroutine arima_vcov(obj, vcov) bind(c, name='arima_vcov')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: vcov
        end subroutine arima_vcov

        subroutine sarima_vcov(obj, vcov) bind(c, name='sarima_vcov')
            import c_double, c_ptr
            type(c_ptr) :: obj
            real(c_double) :: vcov
        end subroutine sarima_vcov

        subroutine sarimax_vcov(obj, vcov) bind(c, name='sarimax_vcov')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: vcov
        end subroutine sarimax_vcov

        subroutine auto_arima_setApproximation(obj, approximation) bind(c, name='auto_arima_setApproximation')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: approximation
        end subroutine auto_arima_setApproximation

        subroutine auto_arima_setStepwise(obj, stepwise) bind(c, name='auto_arima_setStepwise')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: stepwise
        end subroutine auto_arima_setStepwise

        subroutine auto_arima_setStationary(obj, stationary) bind(c, name='auto_arima_setStationary')
            import c_int, c_ptr
            type(c_ptr) :: obj
            integer(c_int), value :: stationary
        end subroutine auto_arima_setStationary

        subroutine auto_arima_setSeasonal(obj, seasonal) bind(c, name='auto_arima_setSeasonal')
            import c_ptr, c_int
            type(c_ptr), value :: obj
            integer(c_int), value :: seasonal
        end subroutine auto_arima_setSeasonal

        subroutine auto_arima_setStationarityParameter(obj, test, alpha, type) bind(c, name='auto_arima_setStationarityParameter')
            import c_ptr, c_double, c_char
            type(c_ptr), value :: obj
            character(c_char) :: test, type
                !!\tocheck:
            real(c_double), value :: alpha
        end subroutine auto_arima_setStationarityParameter

        subroutine auto_arima_setSeasonalParameter(obj, test, alpha) bind(c, name='auto_arima_setSeasonalParameter')
            import c_ptr, c_double, c_char
            type(c_ptr), value :: obj
            character(c_char) :: test
            real(c_double), value :: alpha
        end subroutine auto_arima_setSeasonalParameter

        subroutine auto_arima_setVerbose(obj, verbose) bind(c, name='auto_arima_setVerbose')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: verbose
        end subroutine auto_arima_setVerbose
        ! summary routines 🔻
        subroutine arima_summary(obj) bind(c, name='arima_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine arima_summary

        subroutine sarima_summary(obj) bind(c, name='sarima_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine sarima_summary

        subroutine sarimax_summary(obj) bind(c, name='sarimax_summary')
            import c_ptr
            type(c_ptr), value :: obj
                !! `sarimax_set` struct
        end subroutine sarimax_summary

        subroutine auto_arima_summary(obj) bind(c, name='auto_arima_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine auto_arima_summary

        subroutine ar_estimate(x, N, method) bind(c, name='ar_estimate')
            import c_int, c_double
            real(c_double) :: x
            integer(c_int), value :: N, method
        end subroutine ar_estimate

        subroutine ar_summary(obj) bind(c, name='ar_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine ar_summary

        subroutine model_estimate(x, N, d, pmax, h) bind(c, name='model_estimate')
            import c_int, c_double
            real(c_double) :: x
            integer(c_int), value :: N, d, pmax, h
        end subroutine model_estimate

        subroutine arima_free(object) bind(c, name='arima_free')
            !! free arima struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `arima_objectect`
        end subroutine arima_free

        subroutine sarima_free(object) bind(c, name='sarima_free')
            !! free sarima struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `sarima_object`
        end subroutine sarima_free

        subroutine sarimax_free(object) bind(c, name='sarimax_free')
            !! free sarimax struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `sarimax_object`
        end subroutine sarimax_free

        !&gt; Free auto_arima struct memory
        subroutine auto_arima_free(object) bind(c, name='auto_arima_free')
            import c_ptr
            
            !&gt; Pointer points to `auto_arima_object`
            type(c_ptr), value :: object
            
        end subroutine auto_arima_free

        subroutine ar_free(object) bind(c, name='ar_free')
            !! free ar struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `ar_object`
        end subroutine ar_free

        ! Yule-Walker, Burg and Hannan Rissanen Algorithms for Initial Parameter Estimation
        subroutine yw(x, N, p, phi, var) bind(c, name='yw')
            !! Yule-Walker Algorithms for Initial Parameter Estimation
            import c_int, c_double
            real(c_double) :: var
            real(c_double) :: x(*), phi(*)
            integer(c_int), value :: N, p
        end subroutine yw

        subroutine burg(x, N, p, phi, var) bind(c, name='burg')
            !! Burg Algorithms for Initial Parameter Estimation
            import c_int, c_double
            real(c_double) :: var
            real(c_double) :: x(*), phi(*)
            integer(c_int), value :: N, p
        end subroutine burg

        subroutine hr(x, N, p, q, phi, theta, var) bind(c, name='hr')
            !! Hannan Rissanen Algorithms for Initial Parameter Estimation
            import c_int, c_double
            real(c_double) :: x(*), phi(*), theta(*), var
            integer(c_int), value :: N, p, q
        end subroutine hr
    end interface

contains

    subroutine sarimax_exec(obj, inp, xreg)
        type(c_ptr), intent(in) :: obj
        real(c_double), intent(in) :: inp(*)
        real(c_double), intent(out), optional, target :: xreg(*)
        if (present(xreg)) then
            call ctsa_sarimax_exec(obj, inp, c_loc(xreg))
        else
            call ctsa_sarimax_exec(obj, inp, c_null_ptr)
        end if
    end subroutine sarimax_exec

    subroutine auto_arima_exec(obj, inp, xreg)
        type(c_ptr), intent(in) :: obj
        real(c_double), intent(in) :: inp(*)
        real(c_double), intent(out), optional, target :: xreg(*)
        if (present(xreg)) then
            call ctsa_auto_arima_exec(obj, inp, c_loc(xreg))
        else
            call ctsa_auto_arima_exec(obj, inp, c_null_ptr)
        end if
    end subroutine auto_arima_exec

end module fortsa_model
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../stats/pacf.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../stats/pacf.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
