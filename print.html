<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fortsa api documents</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded "><a href="stats/index.html"><strong aria-hidden="true">2.</strong> fortsa stats</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stats/acf.html"><strong aria-hidden="true">2.1.</strong> acf</a></li><li class="chapter-item expanded "><a href="stats/pacf.html"><strong aria-hidden="true">2.2.</strong> pacf</a></li></ol></li><li class="chapter-item expanded "><a href="model/index.html"><strong aria-hidden="true">3.</strong> fortsa model</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">fortsa api documents</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/zoziha/fortsa/tree/main/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fortsa-a-ctsafortran-binding"><a class="header" href="#fortsa-a-ctsafortran-binding">ForTSA: A CTSA/Fortran binding</a></h1>
<h2 id="a-univariate-time-series-analysis-and-arima-modeling-package-in-fortran"><a class="header" href="#a-univariate-time-series-analysis-and-arima-modeling-package-in-fortran">A Univariate Time Series Analysis and ARIMA Modeling Package in Fortran</a></h2>
<p><code>ForTSA</code> is a Fortran software package for univariate time series analysis, which is base on <a href="https://github.com/rafat/ctsa">rafat/CTSA</a>.<br />
<code>CTSA</code> is a C software package for univariate time series analysis. </p>
<div align="center">
<img src="./media/logo.png" alt="ForTSA" width="220">
</div>
<table><thead><tr><th align="center">Item</th><th align="center">Info</th></tr></thead><tbody>
<tr><td align="center"><strong>Version:</strong></td><td align="center">0.0.3</td></tr>
<tr><td align="center"><strong>Author:</strong></td><td align="center"><code>ForTSA</code> Contributors</td></tr>
<tr><td align="center"><strong>Web site:</strong></td><td align="center">https://github.com/zoziha/fortsa</td></tr>
<tr><td align="center"><strong>API-Doc Web site:</strong></td><td align="center">https://zoziha.github.io/fortsa/</td></tr>
<tr><td align="center"><strong>License:</strong></td><td align="center"><em><code>ForTSA</code></em> is released under BSD-3.</td></tr>
</tbody></table>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<pre><code class="language-sh">git clone https://github.com/zoziha/fortsa.git
cd fortsa
</code></pre>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<ul>
<li>Git</li>
<li><a href="https://github.com/fortran-lang/fpm">fortran-lang/fpm</a></li>
</ul>
<h3 id="supported-compilers"><a class="header" href="#supported-compilers">Supported Compilers</a></h3>
<p>The following combinations are tested on the default branch of <code>ForTSA</code>:</p>
<table><thead><tr><th align="center">Name</th><th align="center">Vesrion</th><th align="center">Platform</th><th align="center">Architecture</th></tr></thead><tbody>
<tr><td align="center">GCC Fortran(MSYS2)</td><td align="center">10</td><td align="center">Windows 10</td><td align="center">x86_64</td></tr>
<tr><td align="center">GCC Fortran</td><td align="center">10</td><td align="center">Ubuntu</td><td align="center">x86_64</td></tr>
</tbody></table>
<h3 id="build-with-a-hrefhttpsgithubcomfortran-langfpmfortran-langfpma"><a class="header" href="#build-with-a-hrefhttpsgithubcomfortran-langfpmfortran-langfpma">Build with <a href="https://github.com/fortran-lang/fpm">fortran-lang/fpm</a></a></h3>
<p>Fortran Package Manager (fpm) is a package manager and build system for Fortran.<br>
You can build using provided <code>fpm.toml</code>:</p>
<pre><code class="language-sh">fpm test --list
fpm test &lt;test_name, see `fpm.toml` or test list&gt;
</code></pre>
<p>To use <code>ForTSA</code> within your fpm project, add the following to <code>fpm.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
fortsa = { git=&quot;https://github.com/zoziha/fortsa.git&quot; }
</code></pre>
<h2 id="ctsa-docs"><a class="header" href="#ctsa-docs"><code>CTSA</code> Docs</a></h2>
<table><thead><tr><th align="left"><strong><a href="https://github.com/rafat/ctsa/wiki/AUTO-ARIMA">Auto ARIMA</a></strong></th><th align="left">Auto ARIMA Class + Examples</th></tr></thead><tbody>
<tr><td align="left"><strong><a href="https://github.com/rafat/ctsa/wiki/SARIMAX/">SARIMAX</a></strong></td><td align="left">SARIMAX Class + Examples</td></tr>
<tr><td align="left"><strong><a href="https://github.com/rafat/ctsa/wiki/ARIMA">ARIMA</a></strong></td><td align="left">ARIMA Class + Example</td></tr>
<tr><td align="left"><strong><a href="https://github.com/rafat/ctsa/wiki/SARIMA">Seasonal ARIMA</a></strong></td><td align="left">Seasonal ARIMA Class + Example</td></tr>
<tr><td align="left"><strong><a href="https://github.com/rafat/ctsa/wiki/AR">AR</a></strong></td><td align="left">AR Class + Example</td></tr>
<tr><td align="left"><strong><a href="https://github.com/rafat/ctsa/wiki/ACF">ACF</a></strong></td><td align="left">Autocovariance, Autocorrelation and Partial Autocorrelation + Examples</td></tr>
<tr><td align="left"><strong><a href="https://github.com/rafat/ctsa/wiki/References">References</a></strong></td><td align="left">References (List Being Updated)</td></tr>
</tbody></table>
<p>Wiki is available at </p>
<p><a href="https://github.com/rafat/ctsa/wiki">ctsa/wiki</a></p>
<p>License : BSD 3- Clause Check LICENSE file</p>
<p>For <code>C</code> routines, contact rafat.hsn@gmail.com.<br />
For <code>Fortran</code> routines, contact zuo.zhihua@qq.com.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ol>
<li><a href="https://github.com/rafat/ctsa">rafat/ctsa</a></li>
<li><a href="https://github.com/vmagnin/gtk-fortran">vmagnin/gtk-fortran</a></li>
<li><a href="https://fortran-lang.org/learn/">fortran-lang</a></li>
<li><a href="https://github.com/fortran-lang/fpm">fortran-lang/fpm</a></li>
<li><a href="https://github.com/zoziha/forlab">zoziha/forlab</a></li>
<li><a href="https://toml.io/en/">toml</a></li>
</ol>
<h2 id="change-log"><a class="header" href="#change-log">Change log</a></h2>
<pre><code class="language-markdown">
2021-07-06  zoziha  zuo.zhihua@qq.com

    Add `CTSA` Fortran interface.

    * src/ctsa/*.c:
    * src/fortsa_dwt.f90:
    * src/fortsa_model.f90:
    * src/fortsa_stats.f90:

    * tests/ctsa/*.c
    * tests/dwt/*.f90
    * tests/model/*.f90
    * tests/stats/*.f90

2021-07-08  zoziha  zuo.zhihua@qq.com

    Improve Fortsa API, change `type(c_ptr)` to more specific types.

    * src/fortsa_dwt.f90
    * src/fortsa_model.f90: `auto_arima_exec` `optional` scheme.
    * src/fortsa_stats.f90:

    * tests/ctsa/*.c
    * tests/dwt/*.f90
    * tests/model/*.f90: 
    * tests/stats/*.f90

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortsa_stats"><a class="header" href="#fortsa_stats">fortsa_stats</a></h1>
<p><code>ctsa/fortsa</code> provides us some useful stats functions.</p>
<pre><code class="language-fortran">module fortsa_stats

    use, intrinsic :: iso_c_binding, only: c_int, c_double
    use, intrinsic :: iso_fortran_env, only: dp =&gt; real64, int32
    implicit none
    private

    public :: acvf, acvf_opt, acvf2acf
    public :: pacf, pacf_opt

    interface
        subroutine ctsa_acvf(vec, N, par, M) bind(c, name='acvf')
            import c_int, c_double
            real(kind=c_double), intent(in) :: vec(*)
            real(kind=c_double), intent(out) :: par(*)
            integer(kind=c_int), value, intent(in) :: N, M
        end subroutine ctsa_acvf

        subroutine ctsa_acvf_opt(vec, N, method, par, M) bind(c, name='acvf_opt')
            import c_int, c_double
            real(kind=c_double), intent(in) :: vec(*)
            real(kind=c_double), intent(out) :: par(*)
            integer(kind=c_int), value, intent(in) :: N, method, M
        end subroutine ctsa_acvf_opt

        pure subroutine ctsa_acvf2acf(acf, M) bind(c, name='acvf2acf')
            import c_int, c_double
            real(kind=c_double), intent(inout) :: acf(*)
            integer(kind=c_int), value, intent(in) :: M
        end subroutine ctsa_acvf2acf

        pure subroutine ctsa_pacf(vec, N, par, M) bind(c, name='pacf')
            import c_int, c_double
            real(kind=c_double), intent(in) :: vec(*)
            real(kind=c_double), intent(out) :: par(*)
            integer(kind=c_int), value, intent(in) :: N, M
        end subroutine ctsa_pacf
        
        subroutine ctsa_pacf_opt(vec, N, method, par, M) bind(c, name='pacf_opt')
            import c_int, c_double
            real(kind=c_double), intent(in) :: vec(*)
            real(kind=c_double), intent(out) :: par(*)
            integer(kind=c_int), value, intent(in) :: N, method, M
        end subroutine ctsa_pacf_opt
    end interface
    
contains

    !&gt; Auto Covariance Function
    subroutine acvf(vec, par)
        real(kind=dp), intent(in) :: vec(:)
        real(kind=dp), intent(out) :: par(:)
        
        call ctsa_acvf(vec, size(vec), par, size(par))
        
    end subroutine acvf
    
    !&gt; Method 0 : Regular Method. Slow for large input length.
    !&gt; Method 1 : FFT based Method. Use it if data length is large
    subroutine acvf_opt(vec, method, par)
        real(kind=dp), intent(in) :: vec(:)
        integer(int32), intent(in) :: method
        real(kind=dp), intent(out) :: par(:)
        
        call ctsa_acvf_opt(vec, size(vec), method, par, size(par))
        
    end subroutine acvf_opt
    
    !&gt; Converts Autocovariance to autocorrelation function
    subroutine acvf2acf(vec)
        real(kind=dp), intent(inout) :: vec(:)
        
        call ctsa_acvf2acf(vec, size(vec))
        
    end subroutine acvf2acf
    
    !&gt; Partial Auto Covariance Function
    subroutine pacf(vec, par)
        real(kind=dp), intent(in) :: vec(:)
        real(kind=dp), intent(out) :: par(:)
        
        call ctsa_pacf(vec, size(vec), par, size(par))
        
    end subroutine pacf
    
    !&gt; Method 0 : Yule-Walker
    !&gt; Method 1 : Burg
    !&gt; Method 2 : Box-Jenkins Conditional MLE
    subroutine pacf_opt(vec, method, par)
        real(kind=dp), intent(in) :: vec(:)
        integer(int32), intent(in) :: method
        real(kind=dp), intent(out) :: par(:)
        
        call ctsa_pacf_opt(vec, size(vec), method, par, size(par))
        
    end subroutine pacf_opt
    

end module fortsa_stats
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acvf"><a class="header" href="#acvf"><code>acvf</code></a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Auto Covariance Function.</p>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<p>Impure subroutine.</p>
<h2 id="synatx"><a class="header" href="#synatx">Synatx</a></h2>
<pre><code class="language-fortran">call fortsa_stats:acvf(vec, n, par, m)
</code></pre>
<h2 id="arguments"><a class="header" href="#arguments">Arguments</a></h2>
<p><code>vec</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(in)</code>.</p>
<p><code>par</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(out)</code>.</p>
<p><code>n</code>, <code>m</code>: Shall be a <code>integer(c_int)</code> scalar.
This argument is <code>value</code> and <code>intent(in)</code>.
<code>n = size(vec)</code>, <code>m = size(par)</code>.</p>
<h1 id="acvf_opt"><a class="header" href="#acvf_opt"><code>acvf_opt</code></a></h1>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Method 0 : Regular Method. Slow for large input length.<br>
Method 1 : FFT based Method. Use it if data length is large.</p>
<h2 id="class-1"><a class="header" href="#class-1">Class</a></h2>
<p>Impure subroutine.</p>
<h2 id="synatx-1"><a class="header" href="#synatx-1">Synatx</a></h2>
<pre><code class="language-fortran">call fortsa_stats:acvf_opt(vec, n, method, par, m)
</code></pre>
<h2 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h2>
<p><code>vec</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(in)</code>.</p>
<p><code>par</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(out)</code>.</p>
<p><code>method</code>: Shall be a <code>integer(c_int)</code> scalar.
This argument is <code>value</code> and <code>intent(in)</code>.</p>
<p><code>n</code>, <code>m</code>: Shall be a <code>integer(c_int)</code> scalar.
This argument is <code>value</code> and <code>intent(in)</code>.
<code>n = size(vec)</code>, <code>m = size(par)</code>.</p>
<h1 id="acvf2acf"><a class="header" href="#acvf2acf"><code>acvf2acf</code></a></h1>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Converts Autocovariance to autocorrelation function.</p>
<h2 id="class-2"><a class="header" href="#class-2">Class</a></h2>
<p>Pure subroutine.</p>
<h2 id="synatx-2"><a class="header" href="#synatx-2">Synatx</a></h2>
<pre><code class="language-fortran">call fortsa_stats:acvf2acf(acf, m)
</code></pre>
<h2 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h2>
<p><code>acf</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(inout)</code>.</p>
<p><code>m</code>: Shall be a <code>integer(c_int)</code> scalar.
This argument is <code>value</code> and <code>intent(in)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pacf"><a class="header" href="#pacf"><code>pacf</code></a></h1>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>Partial Auto Covariance Function.</p>
<h2 id="class-3"><a class="header" href="#class-3">Class</a></h2>
<p>Pure subroutine.</p>
<h2 id="synatx-3"><a class="header" href="#synatx-3">Synatx</a></h2>
<pre><code class="language-fortran">call fortsa_stats:pacf(vec, n, par, m)
</code></pre>
<h2 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h2>
<p><code>vec</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(in)</code>.</p>
<p><code>par</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(out)</code>.</p>
<p><code>n</code>, <code>m</code>: Shall be a <code>integer(c_int)</code> scalar.
This argument is <code>value</code> and <code>intent(in)</code>.
<code>n = size(vec)</code>, <code>m = size(par)</code>.</p>
<h1 id="acvf_opt-1"><a class="header" href="#acvf_opt-1"><code>acvf_opt</code></a></h1>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>Method 0 : Yule-Walker<br>
Method 1 : Burg<br>
Method 2 : Box-Jenkins Conditional MLE</p>
<h2 id="class-4"><a class="header" href="#class-4">Class</a></h2>
<p>Impure subroutine.</p>
<h2 id="synatx-4"><a class="header" href="#synatx-4">Synatx</a></h2>
<pre><code class="language-fortran">call fortsa_stats:pacf_opt(vec, n, method, par, m)
</code></pre>
<h2 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h2>
<p><code>vec</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(in)</code>.</p>
<p><code>par</code>: Shall be a <code>real(c_double)</code> and <code>rank-1</code> array.
This argument is <code>intent(out)</code>.</p>
<p><code>method</code>: Shall be a <code>integer(c_int)</code> scalar.
This argument is <code>value</code> and <code>intent(in)</code>.</p>
<p><code>n</code>, <code>m</code>: Shall be a <code>integer(c_int)</code> scalar.
This argument is <code>value</code> and <code>intent(in)</code>.
<code>n = size(vec)</code>, <code>m = size(par)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortsa_model"><a class="header" href="#fortsa_model">fortsa_model</a></h1>
<p><code>fortsa_model</code> contains useful time series models.</p>
<pre><code class="language-fortran">!! `Fortran-TSA-api.f90` will be the `C-Fortran` interface to [rafat/CTSA](https://github.com/rafat/ctsa)

module fortsa_model

    use, intrinsic :: iso_c_binding, only: c_int, c_double, c_char, c_ptr, c_null_ptr, c_loc
    implicit none
    private

    public :: arima_set, arima_init, arima_setMethod, arima_setOptMethod, &amp;
              arima_exec, arima_summary, arima_predict, arima_free
              
    public :: ar_init, ar_exec, &amp;
              ar_summary, ar_predict, &amp;
              ar_free

    public :: auto_arima_init, auto_arima_setApproximation, auto_arima_exec, &amp;
              auto_arima_summary, auto_arima_predict, &amp;
              auto_arima_free, auto_arima_setStepwise, auto_arima_setVerbose

    public :: sarima_init, sarima_predict, sarima_setMethod, sarima_setOptMethod, &amp;
              sarima_vcov, sarima_exec, sarima_free, sarima_summary

    public :: sarimax_init, sarimax_setMethod, sarimax_exec, &amp;
              sarimax_summary, sarimax_predict, sarimax_free

    public :: yw, burg, hr
    
    public :: auto_arima_set

    type, bind(c) :: auto_arima_set
        integer(c_int) :: N        !! length of time series
        integer(c_int) :: Nused    !! length of time series after differencing, Nused = N - d
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: pmax     !! Maximum size of phi
        integer(c_int) :: dmax     !! Maximum Number of times the series is to be differenced
        integer(c_int) :: qmax     !! Maximum size of theta
        integer(c_int) :: pmax_    !! Maximum Size of seasonal phi
        integer(c_int) :: dmax_    !! Maximum number of times the seasonal series is to be differenced
        integer(c_int) :: qmax_    !! Maximum size of Seasonal Theta
        integer(c_int) :: p        !! size of phi
        integer(c_int) :: d        !! Number of times the series is to be differenced
        integer(c_int) :: q        !! size of theta
        integer(c_int) :: s        !! Seasonality/Period
        integer(c_int) :: p_       !! Size of seasonal phi
        integer(c_int) :: d_       !! The number of times the seasonal series is to be differenced
        integer(c_int) :: q_       !! size of Seasonal Theta
        integer(c_int) :: r        !! Number of exogenous variables
        integer(c_int) :: M        !! M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !! Total Number of Coefficients to be estimated
        real(c_double) :: phi
        real(c_double) :: theta
        real(c_double) :: phi_
        real(c_double) :: theta_
        real(c_double) :: exog
        real(c_double) :: vcov     !! Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !! length of VCOV
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: ic
        integer(c_int) :: retval
        integer(c_int) :: start
        integer(c_int) :: imean
        integer(c_int) :: idrift
        integer(c_int) :: stationary
        integer(c_int) :: seasonal
        integer(c_int) :: Order_max
        integer(c_int) :: p_start
        integer(c_int) :: q_start
        integer(c_int) :: P_start_
        integer(c_int) :: Q_start_
        character(c_char), dimension(10) :: information_criteria
        integer(c_int) :: stepwise
        integer(c_int) :: num_models
        integer(c_int) :: approximation
        integer(c_int) :: verbose
        character(c_char), dimension(10) :: test
        character(c_char), dimension(10) :: type
        character(c_char), dimension(10) :: seas
        real(c_double) :: alpha_test
        real(c_double) :: alpha_seas
        real(c_double) :: lambda
        real(c_double) :: sigma2
        real(c_double) :: aic
        real(c_double) :: bic
        real(c_double) :: aicc
        real(c_double), dimension(0) :: params
    end type auto_arima_set

    interface
        function auto_arima_init(pdqmax, pdqmax_, s, r, N) bind(c, name='auto_arima_init')
            import c_int, c_ptr
            integer(c_int) :: pdqmax(*), pdqmax_(*)
            integer(c_int), value :: s, r, N
            type(c_ptr) :: auto_arima_init
        end function auto_arima_init
    end interface

    type, bind(c) :: sarimax_set
        integer(c_int) :: N        !! length of time series
        integer(c_int) :: Nused    !!length of time series after differencing, Nused = N - d
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: p        !! size of phi
        integer(c_int) :: d        !! Number of times the series is to be differenced
        integer(c_int) :: q        !!size of theta
        integer(c_int) :: s        !! Seasonality/Period
        integer(c_int) :: p_       !!Size of seasonal phi
        integer(c_int) :: d_       !! The number of times the seasonal series is to be differenced
        integer(c_int) :: q_       !!size of Seasonal Theta
        integer(c_int) :: r        !! Number of exogenous variables
        integer(c_int) :: M        !! M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !! Total Number of Coefficients to be estimated
        real(c_double) :: phi
        real(c_double) :: theta
        real(c_double) :: phi_
        real(c_double) :: theta_
        real(c_double) :: exog
        real(c_double) :: vcov     !! Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !!length of VCOV
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: aic
        integer(c_int) :: retval
        integer(c_int) :: start
        integer(c_int) :: imean
        real(c_double), dimension(0) :: params
    end type sarimax_set

    interface
        function sarimax_init(p, d, q, p_, d_, q_, s, r, imean, N) bind(c, name='sarimax_init')
            import c_int, c_ptr
            integer(c_int), value :: p, d, q, p_, d_, q_, s, r, imean, N
            type(c_ptr) :: sarimax_init
                !! `sarimax_set` struct
        end function sarimax_init
    end interface

    type, bind(c) :: arima_set
        integer(c_int) :: N        !! length of time series
        integer(c_int) :: Nused    !! length of time series after differencing, Nused = N - d
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: p        !! size of phi
        integer(c_int) :: d        !! Number of times the series is to be differenced
        integer(c_int) :: q        !! size of theta
        integer(c_int) :: s        !! Seasonality/Period
        integer(c_int) :: p_       !! Size of seasonal phi
        integer(c_int) :: d_       !! The number of times the seasonal series is to be differenced
        integer(c_int) :: q_       !! size of Seasonal Theta
        integer(c_int) :: r        !! Number of exogenous variables
        integer(c_int) :: M        !! M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !! Total Number of Coefficients to be estimated
        type(c_ptr) :: phi
        type(c_ptr) :: theta
        type(c_ptr) :: phi_
        type(c_ptr) :: theta_
        type(c_ptr) :: exog
        type(c_ptr) :: vcov     !! Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !! length of VCOV
        type(c_ptr) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: aic
        integer(c_int) :: retval
        integer(c_int) :: start
        integer(c_int) :: imean
        real(c_double), dimension(0) :: params
    end type

    ! type(c_ptr), bind(c, name='arima_object') :: arima_object

    interface
        function arima_init(p, d, q, N) bind(c, name='arima_init')
            import c_int, c_ptr
            integer(c_int), value :: p, d, q, N
            type(c_ptr) :: arima_init
        end function
    end interface

    type, bind(c) :: sarima_set
        integer(c_int) :: N        !!  length of time series
        integer(c_int) :: Nused    !! length of time series after differencing, Nused = N - d - s*D
        integer(c_int) :: method
        integer(c_int) :: optmethod
        integer(c_int) :: p        !!  size of phi
        integer(c_int) :: d        !!  Number of times the series is to be differenced
        integer(c_int) :: q        !! size of theta
        integer(c_int) :: s        !!  Seasonality/Period
        integer(c_int) :: P_        !! Size of seasonal phi
        integer(c_int) :: D_        !!  The number of times the seasonal series is to be differenced
        integer(c_int) :: Q_        !! size of Seasonal Theta
        integer(c_int) :: M        !!  M = 0 if mean is 0.0 else M = 1
        integer(c_int) :: ncoeff   !!  Total Number of Coefficients to be estimated
        real(c_double) :: phi
        real(c_double) :: theta
        real(c_double) :: PHI_
        real(c_double) :: THETA_
        real(c_double) :: vcov    !!  Variance-Covariance Matrix Of length lvcov
        integer(c_int) :: lvcov    !! length of VCOV
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: loglik
        real(c_double) :: aic
        integer(c_int) :: retval
        real(c_double), dimension(0) :: params
    end type

    interface
        function sarima_init(p, d, q, s, p_, d_, q_, N) bind(c, name='sarima_init')
            import c_int, c_ptr
            integer(c_int), value :: p, d, q, s, p_, d_, q_, N
            type(c_ptr) :: sarima_init
        end function
    end interface

    type, bind(c) :: ar_set
        integer(c_int) :: N            !! length of time series
        integer(c_int) :: method
        integer(c_int) :: optmethod    !! Valid only for MLE estimation
        integer(c_int) :: p            !! size of phi
        integer(c_int) :: order        !! order = p
        integer(c_int) :: ordermax     !! Set Maximum order to be fit
        real(c_double) :: phi
        real(c_double) :: res
        real(c_double) :: mean
        real(c_double) :: var
        real(c_double) :: aic
        integer(c_int) :: retval
        real(c_double), dimension(0) :: params
    end type

    interface
        function ar_init(method, N) bind(c, name='ar_init')
            import c_int, c_ptr
            integer(c_int), value :: method, N
            type(c_ptr) :: ar_init
        end function
    end interface

    interface
        ! exec routines 🔻
        subroutine ctsa_sarimax_exec(obj, inp, xreg) bind(c, name='sarimax_exec')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: inp(*)
            type(c_ptr), value :: xreg
        end subroutine ctsa_sarimax_exec

        subroutine arima_exec(obj, x) bind(c, name='arima_exec')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: x(*)
        end subroutine arima_exec

        subroutine sarima_exec(obj, x) bind(c, name='sarima_exec')
            import c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: x(*)
        end subroutine sarima_exec

        subroutine ctsa_auto_arima_exec(obj, inp, xreg) bind(c, name='auto_arima_exec')
            import c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*)
            type(c_ptr), value :: xreg
        end subroutine ctsa_auto_arima_exec

        subroutine ar_exec(obj, inp) bind(c, name='ar_exec')
            import c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*)
        end subroutine ar_exec
        ! predict routines 🔻
        subroutine arima_predict(obj, inp, L, xpred, amse) bind(c, name='arima_predict')
            import c_int, c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine arima_predict

        subroutine sarima_predict(obj, inp, L, xpred, amse) bind(c, name='sarima_predict')
            import c_int, c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine sarima_predict

        subroutine sarimax_predict(obj, inp, xreg, L, newxreg, xpred, amse) bind(c, name='sarimax_predict')
            import c_ptr, c_int, c_double
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xreg(*), newxreg(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine sarimax_predict

        !&gt; Predictes the next L values of the time series
        subroutine auto_arima_predict(obj, inp, xreg, L, newxreg, xpred, amse) bind(c)
            import c_int, c_ptr, c_double
            
            !&gt; Pointer points to `auto_arima_object`
            type(c_ptr), value :: obj
            
            !&gt; Input array
            real(c_double) :: inp(*)
            
            !&gt; TODO:
            real(c_double) :: xreg(*), newxreg(*)
            
            !&gt; Prediction array
            real(c_double) :: xpred(*)
            
            !&gt; Standard errors array
            real(c_double) :: amse(*)
            
            !&gt; Length of prediction
            integer(c_int), value :: L
            
        end subroutine auto_arima_predict

        subroutine ar_predict(obj, inp, L, xpred, amse) bind(c, name='ar_predict')
            import c_int, c_double, c_ptr
            type(c_ptr), value :: obj
            real(c_double) :: inp(*), xpred(*), amse(*)
            integer(c_int), value :: L
        end subroutine ar_predict

        subroutine ar(inp, N, p, method, phi, var) bind(c, name='ar')
            import c_int, c_double
            real(c_double) :: inp, phi, var
            integer(c_int), value :: N, p, method
        end subroutine ar
        
        ! setMethod routines 🔻
        subroutine arima_setMethod(obj, value) bind(c, name='arima_setMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine arima_setMethod

        subroutine sarima_setMethod(obj, value) bind(c, name='sarima_setMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine sarima_setMethod

        subroutine auto_arima_setMethod(obj, value) bind(c, name='auto_arima_setMethod')
            import c_ptr, c_int
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine auto_arima_setMethod

        subroutine sarimax_setMethod(obj, value) bind(c, name='sarimax_setMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine sarimax_setMethod
        ! setOptMethod routines 🔻
        subroutine arima_setOptMethod(obj, value) bind(c, name='arima_setOptMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine arima_setOptMethod

        subroutine sarima_setOptMethod(obj, value) bind(c, name='sarima_setOptMethod')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine sarima_setOptMethod

        subroutine auto_arima_setOptMethod(obj, value) bind(c, name='auto_arima_setOptMethod')
            import c_ptr, c_int
            type(c_ptr), value :: obj
            integer(c_int), value :: value
        end subroutine auto_arima_setOptMethod

        subroutine arima_vcov(obj, vcov) bind(c, name='arima_vcov')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: vcov
        end subroutine arima_vcov

        subroutine sarima_vcov(obj, vcov) bind(c, name='sarima_vcov')
            import c_double, c_ptr
            type(c_ptr) :: obj
            real(c_double) :: vcov
        end subroutine sarima_vcov

        subroutine sarimax_vcov(obj, vcov) bind(c, name='sarimax_vcov')
            import c_ptr, c_double
            type(c_ptr), value :: obj
            real(c_double) :: vcov
        end subroutine sarimax_vcov

        subroutine auto_arima_setApproximation(obj, approximation) bind(c, name='auto_arima_setApproximation')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: approximation
        end subroutine auto_arima_setApproximation

        subroutine auto_arima_setStepwise(obj, stepwise) bind(c, name='auto_arima_setStepwise')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: stepwise
        end subroutine auto_arima_setStepwise

        subroutine auto_arima_setStationary(obj, stationary) bind(c, name='auto_arima_setStationary')
            import c_int, c_ptr
            type(c_ptr) :: obj
            integer(c_int), value :: stationary
        end subroutine auto_arima_setStationary

        subroutine auto_arima_setSeasonal(obj, seasonal) bind(c, name='auto_arima_setSeasonal')
            import c_ptr, c_int
            type(c_ptr), value :: obj
            integer(c_int), value :: seasonal
        end subroutine auto_arima_setSeasonal

        subroutine auto_arima_setStationarityParameter(obj, test, alpha, type) bind(c, name='auto_arima_setStationarityParameter')
            import c_ptr, c_double, c_char
            type(c_ptr), value :: obj
            character(c_char) :: test, type
                !!\tocheck:
            real(c_double), value :: alpha
        end subroutine auto_arima_setStationarityParameter

        subroutine auto_arima_setSeasonalParameter(obj, test, alpha) bind(c, name='auto_arima_setSeasonalParameter')
            import c_ptr, c_double, c_char
            type(c_ptr), value :: obj
            character(c_char) :: test
            real(c_double), value :: alpha
        end subroutine auto_arima_setSeasonalParameter

        subroutine auto_arima_setVerbose(obj, verbose) bind(c, name='auto_arima_setVerbose')
            import c_int, c_ptr
            type(c_ptr), value :: obj
            integer(c_int), value :: verbose
        end subroutine auto_arima_setVerbose
        ! summary routines 🔻
        subroutine arima_summary(obj) bind(c, name='arima_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine arima_summary

        subroutine sarima_summary(obj) bind(c, name='sarima_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine sarima_summary

        subroutine sarimax_summary(obj) bind(c, name='sarimax_summary')
            import c_ptr
            type(c_ptr), value :: obj
                !! `sarimax_set` struct
        end subroutine sarimax_summary

        subroutine auto_arima_summary(obj) bind(c, name='auto_arima_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine auto_arima_summary

        subroutine ar_estimate(x, N, method) bind(c, name='ar_estimate')
            import c_int, c_double
            real(c_double) :: x
            integer(c_int), value :: N, method
        end subroutine ar_estimate

        subroutine ar_summary(obj) bind(c, name='ar_summary')
            import c_ptr
            type(c_ptr), value :: obj
        end subroutine ar_summary

        subroutine model_estimate(x, N, d, pmax, h) bind(c, name='model_estimate')
            import c_int, c_double
            real(c_double) :: x
            integer(c_int), value :: N, d, pmax, h
        end subroutine model_estimate

        subroutine arima_free(object) bind(c, name='arima_free')
            !! free arima struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `arima_objectect`
        end subroutine arima_free

        subroutine sarima_free(object) bind(c, name='sarima_free')
            !! free sarima struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `sarima_object`
        end subroutine sarima_free

        subroutine sarimax_free(object) bind(c, name='sarimax_free')
            !! free sarimax struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `sarimax_object`
        end subroutine sarimax_free

        !&gt; Free auto_arima struct memory
        subroutine auto_arima_free(object) bind(c, name='auto_arima_free')
            import c_ptr
            
            !&gt; Pointer points to `auto_arima_object`
            type(c_ptr), value :: object
            
        end subroutine auto_arima_free

        subroutine ar_free(object) bind(c, name='ar_free')
            !! free ar struct memory
            import c_ptr
            type(c_ptr), value :: object
                !! pointer points to `ar_object`
        end subroutine ar_free

        ! Yule-Walker, Burg and Hannan Rissanen Algorithms for Initial Parameter Estimation
        subroutine yw(x, N, p, phi, var) bind(c, name='yw')
            !! Yule-Walker Algorithms for Initial Parameter Estimation
            import c_int, c_double
            real(c_double) :: var
            real(c_double) :: x(*), phi(*)
            integer(c_int), value :: N, p
        end subroutine yw

        subroutine burg(x, N, p, phi, var) bind(c, name='burg')
            !! Burg Algorithms for Initial Parameter Estimation
            import c_int, c_double
            real(c_double) :: var
            real(c_double) :: x(*), phi(*)
            integer(c_int), value :: N, p
        end subroutine burg

        subroutine hr(x, N, p, q, phi, theta, var) bind(c, name='hr')
            !! Hannan Rissanen Algorithms for Initial Parameter Estimation
            import c_int, c_double
            real(c_double) :: x(*), phi(*), theta(*), var
            integer(c_int), value :: N, p, q
        end subroutine hr
    end interface

contains

    subroutine sarimax_exec(obj, inp, xreg)
        type(c_ptr), intent(in) :: obj
        real(c_double), intent(in) :: inp(*)
        real(c_double), intent(out), optional, target :: xreg(*)
        if (present(xreg)) then
            call ctsa_sarimax_exec(obj, inp, c_loc(xreg))
        else
            call ctsa_sarimax_exec(obj, inp, c_null_ptr)
        end if
    end subroutine sarimax_exec

    subroutine auto_arima_exec(obj, inp, xreg)
        type(c_ptr), intent(in) :: obj
        real(c_double), intent(in) :: inp(*)
        real(c_double), intent(out), optional, target :: xreg(*)
        if (present(xreg)) then
            call ctsa_auto_arima_exec(obj, inp, c_loc(xreg))
        else
            call ctsa_auto_arima_exec(obj, inp, c_null_ptr)
        end if
    end subroutine auto_arima_exec

end module fortsa_model
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
